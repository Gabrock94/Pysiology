
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>electrocardiography &#8212; Pysiology 0.0.9 - Beta version documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Pysiology 0.0.9 - Beta version documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for electrocardiography</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">peakutils</span> <span class="c1">#peak detection for IBI / BPM</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> <span class="c1">#to handle datas</span>
<span class="kn">import</span> <span class="nn">math</span> <span class="c1">#to handle mathematical stuff (example power of 2)</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="k">import</span> <span class="n">butter</span><span class="p">,</span> <span class="n">lfilter</span>  <span class="c1">#for signal filtering</span>
<span class="kn">import</span> <span class="nn">scipy</span>

<div class="viewcode-block" id="getIBI"><a class="viewcode-back" href="../heartrate.html#electrocardiography.getIBI">[docs]</a><span class="k">def</span> <span class="nf">getIBI</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span><span class="n">samplerate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This function returns the IBI of a discrete heart signal.</span>
<span class="sd">    </span>
<span class="sd">        Input: peaks and samplerate of the ECG signal</span>
<span class="sd">        </span>
<span class="sd">        Output: IBI in ms</span>
<span class="sd">        </span>
<span class="sd">        :param peaks: list of peaks of the ECG signal</span>
<span class="sd">        :type peaks: list</span>
<span class="sd">        :param samplerate: samplerate of the signal in Hz</span>
<span class="sd">        :type samplerate: int</span>
<span class="sd">        :return: the mean IBI of the ECG signal</span>
<span class="sd">        :rtype: IBI (in ms) as float value</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">delta</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">peakIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)):</span>
        <span class="n">delta</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">peaks</span><span class="p">[</span><span class="n">peakIndex</span><span class="p">]</span> <span class="o">-</span> <span class="n">peaks</span><span class="p">[</span><span class="n">peakIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">samplerate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">IBI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> 
    <span class="k">return</span><span class="p">(</span><span class="n">IBI</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="getBPM"><a class="viewcode-back" href="../heartrate.html#electrocardiography.getBPM">[docs]</a><span class="k">def</span> <span class="nf">getBPM</span><span class="p">(</span><span class="n">npeaks</span><span class="p">,</span><span class="n">nsample</span><span class="p">,</span> <span class="n">samplerate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This function returns the BPM of a discrete heart signal.</span>
<span class="sd">    </span>
<span class="sd">        Input: number of peaks of the ECG signal,number of samples, samplerate of the signal</span>
<span class="sd">        </span>
<span class="sd">        Output: BPM</span>
<span class="sd">        </span>
<span class="sd">        :param npeak: number of peaks of the ECG signal</span>
<span class="sd">        :type npeak: int</span>
<span class="sd">        :param nsample: number of samples of the ECG signal</span>
<span class="sd">        :type nsample: int</span>
<span class="sd">        :param samplerate: samplerate of the signal in Hz</span>
<span class="sd">        :type samplerate: int</span>
<span class="sd">        :return: BPM of the ECG signal</span>
<span class="sd">        :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">samplelen</span> <span class="o">=</span> <span class="n">nsample</span> <span class="o">/</span> <span class="n">samplerate</span> <span class="c1">#lenght in seconds</span>
    <span class="n">BPM</span> <span class="o">=</span> <span class="p">(</span><span class="n">npeaks</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span> <span class="o">/</span> <span class="n">samplelen</span>
    <span class="k">return</span><span class="p">(</span><span class="n">BPM</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="getSDNN"><a class="viewcode-back" href="../heartrate.html#electrocardiography.getSDNN">[docs]</a><span class="k">def</span> <span class="nf">getSDNN</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span><span class="n">samplerate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This functions evaluate the standard deviation of intervals between heartbeats.</span>
<span class="sd">        It is often calculated over 24h period, or over short peridos of 5 mins.</span>
<span class="sd">        </span>
<span class="sd">        SDNN reflects all the cyclic components responsible for variability in the period of recording, therefore it represents total variability</span>
<span class="sd">        </span>
<span class="sd">        SDNN = sqrt((1/N-1) * sum(i=1 --&gt; N)(rri - rrmean)^2)</span>
<span class="sd">        </span>
<span class="sd">        Input: peaks of the ECG signal,samplerate of the signal</span>
<span class="sd">        </span>
<span class="sd">        Output: standard deviations of Intervals between heartbeats.</span>
<span class="sd">        </span>
<span class="sd">        :param peaks: list of peaks in the ECG signal</span>
<span class="sd">        :type peaks: list</span>
<span class="sd">        :param samplerate: samplerate of the signal in Hz</span>
<span class="sd">        :type samplerate: int</span>
<span class="sd">        :return: the SDNN of the ECG signal</span>
<span class="sd">        :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">peakIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)):</span>
        <span class="n">delta</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">peaks</span><span class="p">[</span><span class="n">peakIndex</span><span class="p">]</span> <span class="o">-</span> <span class="n">peaks</span><span class="p">[</span><span class="n">peakIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">samplerate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">SDNN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">SDNN</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="getSDSD"><a class="viewcode-back" href="../heartrate.html#electrocardiography.getSDSD">[docs]</a><span class="k">def</span> <span class="nf">getSDSD</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span><span class="n">samplerate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This functions evaluate the the standard deviation of successive differences between adjacent R-R intervals.</span>
<span class="sd">    </span>
<span class="sd">        SDSD: sqrt((1 / (N - 1)) * sum(i=1 --&gt; N)(RR i - mean(RR))**2)</span>
<span class="sd">        </span>
<span class="sd">        Input: peaks of the ECG signal,samplerate of the signal</span>
<span class="sd">        </span>
<span class="sd">        Output: the standard deviation of successive differences between adjacent R-R intervals</span>
<span class="sd">        </span>
<span class="sd">        :param peaks: list of peaks in the ECG signal</span>
<span class="sd">        :type peaks: list</span>
<span class="sd">        :param samplerate: samplerate of the signal in Hz</span>
<span class="sd">        :type samplerate: int</span>
<span class="sd">        :return: the SDSD of the ECG signal</span>
<span class="sd">        :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">peakIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)):</span>
        <span class="n">delta</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">peaks</span><span class="p">[</span><span class="n">peakIndex</span><span class="p">]</span> <span class="o">-</span> <span class="n">peaks</span><span class="p">[</span><span class="n">peakIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">samplerate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
    
    <span class="n">differences</span> <span class="o">=</span> <span class="p">[]</span> 
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">delta</span><span class="p">)):</span>
        <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
    <span class="n">SDSD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">differences</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">SDSD</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="getRMSSD"><a class="viewcode-back" href="../heartrate.html#electrocardiography.getRMSSD">[docs]</a><span class="k">def</span> <span class="nf">getRMSSD</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span><span class="n">samplerate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This functions evaluate the root mean square of successive differences between adjacent R-R intervals.</span>
<span class="sd">    </span>
<span class="sd">        RMSSD = sqrt((1 / (N - 1)) * sum(i=1 --&gt; N)(RRdiff i - mean(RRdiff))**2)</span>
<span class="sd">        </span>
<span class="sd">        Input: peaks of the ECG signal,samplerate of the signal.</span>
<span class="sd">        </span>
<span class="sd">        Output: the root mean square of successive differences between adjacent R-R intervals.</span>
<span class="sd">        </span>
<span class="sd">        :param peaks: list of peaks in the ECG signal</span>
<span class="sd">        :type peaks: list</span>
<span class="sd">        :param samplerate: samplerate of the signal in Hz</span>
<span class="sd">        :type samplerate: int</span>
<span class="sd">        :return: the RMSSD of the ECG signal</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">peakIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)):</span>
        <span class="n">delta</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">peaks</span><span class="p">[</span><span class="n">peakIndex</span><span class="p">]</span> <span class="o">-</span> <span class="n">peaks</span><span class="p">[</span><span class="n">peakIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">samplerate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
    
    <span class="n">differences</span> <span class="o">=</span> <span class="p">[]</span> 
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">delta</span><span class="p">)):</span>
        <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">))</span>
        
    <span class="n">RMSSD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">differences</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">RMSSD</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="getPNN50"><a class="viewcode-back" href="../heartrate.html#electrocardiography.getPNN50">[docs]</a><span class="k">def</span> <span class="nf">getPNN50</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span><span class="n">samplerate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This functions evaluate pNN50, the proportion of differences greater than 50ms.</span>
<span class="sd">    </span>
<span class="sd">        Input: peaks of the ECG signal,samplerate of the signal</span>
<span class="sd">        </span>
<span class="sd">        Output: proportion of number of pairs of successive peaks that diffear by more than 50ms</span>
<span class="sd">        </span>
<span class="sd">        :param peaks: list of peaks in the ECG signal</span>
<span class="sd">        :type peaks: list</span>
<span class="sd">        :param samplerate: samplerate of the signal in Hz</span>
<span class="sd">        :type samplerate: int</span>
<span class="sd">        :return: the pNN50 of the ECG signal</span>
<span class="sd">        :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">peakIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)):</span>
        <span class="n">delta</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">peaks</span><span class="p">[</span><span class="n">peakIndex</span><span class="p">]</span> <span class="o">-</span> <span class="n">peaks</span><span class="p">[</span><span class="n">peakIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">samplerate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
    
    <span class="n">differences</span> <span class="o">=</span> <span class="p">[]</span> 
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">delta</span><span class="p">)):</span>
        <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
    <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">differences</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">NN50</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">differences</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">]</span>
        <span class="n">pNN50</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NN50</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">differences</span><span class="p">))</span>
        <span class="k">return</span><span class="p">(</span><span class="n">pNN50</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="getPNN20"><a class="viewcode-back" href="../heartrate.html#electrocardiography.getPNN20">[docs]</a><span class="k">def</span> <span class="nf">getPNN20</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span><span class="n">samplerate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This functions evaluate pNN20, the proportion of differences greater than 20ms.</span>
<span class="sd">    </span>
<span class="sd">        Input: peaks of the ECG signal,samplerate of the signal</span>
<span class="sd">        </span>
<span class="sd">        Output: proportion of number of pairs of successive peaks that diffear by more than 20ms</span>
<span class="sd">        </span>
<span class="sd">        :param peaks: list of peaks in the ECG signal</span>
<span class="sd">        :type peaks: list</span>
<span class="sd">        :param samplerate: samplerate of the signal in Hz</span>
<span class="sd">        :type samplerate: int</span>
<span class="sd">        :return: the pNN20 of the ECG signal</span>
<span class="sd">        :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">peakIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)):</span>
        <span class="n">delta</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">peaks</span><span class="p">[</span><span class="n">peakIndex</span><span class="p">]</span> <span class="o">-</span> <span class="n">peaks</span><span class="p">[</span><span class="n">peakIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">samplerate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
    
    <span class="n">differences</span> <span class="o">=</span> <span class="p">[]</span> 
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">delta</span><span class="p">)):</span>
        <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">differences</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">):</span>  
        <span class="n">NN20</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">differences</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">]</span>
        <span class="n">pNN20</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NN20</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">differences</span><span class="p">))</span>
        <span class="k">return</span><span class="p">(</span><span class="n">pNN20</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">getPSD</span><span class="p">(</span><span class="n">rawECGSignal</span><span class="p">,</span> <span class="n">samplerate</span><span class="p">):</span>
    <span class="n">frequencies</span><span class="p">,</span> <span class="n">psd</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">periodogram</span><span class="p">(</span><span class="n">rawECGSignal</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">samplerate</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s2">&quot;spectrum&quot;</span><span class="p">)</span>
    <span class="k">return</span><span class="p">([</span><span class="n">psd</span><span class="p">,</span><span class="n">frequencies</span><span class="p">])</span> 
    
<div class="viewcode-block" id="getFrequencies"><a class="viewcode-back" href="../heartrate.html#electrocardiography.getFrequencies">[docs]</a><span class="k">def</span> <span class="nf">getFrequencies</span><span class="p">(</span><span class="n">rawECGSignal</span><span class="p">,</span> <span class="n">samplerate</span><span class="p">,</span> <span class="n">llc</span><span class="o">=</span><span class="mf">0.04</span><span class="p">,</span> <span class="n">ulc</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span> <span class="n">lhc</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span><span class="n">uhc</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">lvlc</span> <span class="o">=</span> <span class="mf">0.0033</span> <span class="p">,</span> <span class="n">hvlc</span> <span class="o">=</span> <span class="mf">0.04</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This functions returns the sum of the PSD of low Frequencies, high frequencies and very low frequencies.</span>
<span class="sd">    </span>
<span class="sd">       Default Values have been adapted from: Blood, J. D., Wu, J., Chaplin, T. M., Hommer, R., Vazquez, L., Rutherford, H. J., ... &amp; Crowley, M. J. (2015). The variable heart: high frequency and very low frequency correlates of depressive symptoms in children and adolescents. Journal of affective disorders, 186, 119-126.</span>
<span class="sd">       </span>
<span class="sd">       It returns a dictionary with the values for high, low and very low frequencies</span>
<span class="sd">       </span>
<span class="sd">       :param rawECGSignal: raw ECG signal</span>
<span class="sd">       :type rawECGSignal: list</span>
<span class="sd">       :param samplerate: samplerate of the ECG signal</span>
<span class="sd">       :type samplerate: int</span>
<span class="sd">       :param llc: lower cutoff of low frequencies</span>
<span class="sd">       :type llc: float</span>
<span class="sd">       :param ulc: upper cutoff of low frequencies</span>
<span class="sd">       :type ulc: float</span>
<span class="sd">       :param lhc: lower cutoff of high frequencies</span>
<span class="sd">       :type lhc: float</span>
<span class="sd">       :param uhc: high cutoff of high frequencies</span>
<span class="sd">       :type uhc: float</span>
<span class="sd">       :param lvlc: lower cutoff of very low frequencies</span>
<span class="sd">       :type lvlc: float</span>
<span class="sd">       :param uvlc: upper cutoff of very low frequencies</span>
<span class="sd">       :type uvlc: float</span>

<span class="sd">       :return: a dictionary containing the results of the frequency analysis</span>
<span class="sd">       :rtype: dictionary</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frequencyAnalysis</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">rawECGPowerSpectrum</span><span class="p">,</span> <span class="n">frequencies</span> <span class="o">=</span> <span class="n">getPSD</span><span class="p">(</span><span class="n">rawECGSignal</span><span class="p">,</span><span class="n">samplerate</span><span class="p">)</span>
    <span class="n">frequencies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span>
    <span class="n">llc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">llc</span><span class="p">))</span>
    <span class="n">ulc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">ulc</span><span class="p">))</span>
    <span class="n">lhc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">lhc</span><span class="p">))</span>
    <span class="n">uhc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">uhc</span><span class="p">))</span>
    <span class="n">hvlc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">hvlc</span><span class="p">))</span>
    <span class="n">lvlc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">lvlc</span><span class="p">))</span>
    <span class="n">frequencyAnalysis</span><span class="p">[</span><span class="s2">&quot;LF&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">P</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">rawECGPowerSpectrum</span><span class="p">[</span><span class="n">frequencies</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">llc</span><span class="p">):</span><span class="n">frequencies</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ulc</span><span class="p">)]])</span>
    <span class="n">frequencyAnalysis</span><span class="p">[</span><span class="s2">&quot;HF&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">P</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">rawECGPowerSpectrum</span><span class="p">[</span><span class="n">frequencies</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">lhc</span><span class="p">):</span><span class="n">frequencies</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">uhc</span><span class="p">)]])</span>
    <span class="n">frequencyAnalysis</span><span class="p">[</span><span class="s2">&quot;VLF&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">P</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">rawECGPowerSpectrum</span><span class="p">[</span><span class="n">frequencies</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">lvlc</span><span class="p">):</span><span class="n">frequencies</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">hvlc</span><span class="p">)]])</span>
    
    <span class="k">return</span><span class="p">(</span><span class="n">frequencyAnalysis</span><span class="p">)</span></div>
    
<span class="c1">#Define the filters</span>
<div class="viewcode-block" id="butter_lowpass"><a class="viewcode-back" href="../heartrate.html#electrocardiography.butter_lowpass">[docs]</a><span class="k">def</span> <span class="nf">butter_lowpass</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This functions generates a lowpass butter filter</span>
<span class="sd">    </span>
<span class="sd">        :param cutoff: cutoff frequency</span>
<span class="sd">        :type cutoff: float</span>
<span class="sd">        :param cutoff: cutoff frequency</span>
<span class="sd">        :type cutoff: float</span>
<span class="sd">        :param fs: samplerate of the signal</span>
<span class="sd">        :type fs: float</span>
<span class="sd">        :param order: order of the Butter Filter</span>
<span class="sd">        :type order: int</span>

<span class="sd">        :return: butter lowpass filter</span>
<span class="sd">        :rtype: list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nyq</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">fs</span> <span class="c1">#Nyquist frequeny is half the sampling frequency</span>
    <span class="n">normal_cutoff</span> <span class="o">=</span> <span class="n">cutoff</span> <span class="o">/</span> <span class="n">nyq</span> 
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">butter</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">normal_cutoff</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="butter_highpass"><a class="viewcode-back" href="../heartrate.html#electrocardiography.butter_highpass">[docs]</a><span class="k">def</span> <span class="nf">butter_highpass</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This functions generates a higpass butter filter</span>
<span class="sd">    </span>
<span class="sd">        :param cutoff: cutoff frequency</span>
<span class="sd">        :type cutoff: float</span>
<span class="sd">        :param cutoff: cutoff frequency</span>
<span class="sd">        :type cutoff: float</span>
<span class="sd">        :param fs: samplerate of the signal</span>
<span class="sd">        :type fs: float</span>
<span class="sd">        :param order: order of the Butter Filter</span>
<span class="sd">        :type order: int</span>

<span class="sd">        :return: butter highpass filter</span>
<span class="sd">        :rtype: list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nyq</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">fs</span> <span class="c1">#Nyquist frequeny is half the sampling frequency</span>
    <span class="n">normal_cutoff</span> <span class="o">=</span> <span class="n">cutoff</span> <span class="o">/</span> <span class="n">nyq</span> 
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">butter</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">normal_cutoff</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="butter_lowpass_filter"><a class="viewcode-back" href="../heartrate.html#electrocardiography.butter_lowpass_filter">[docs]</a><span class="k">def</span> <span class="nf">butter_lowpass_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This functions apply a butter lowpass filter to a signal</span>
<span class="sd">    </span>
<span class="sd">        :param data: ECG signal</span>
<span class="sd">        :type data: list</span>
<span class="sd">        :param cutoff: cutoff frequency</span>
<span class="sd">        :type cutoff: float</span>
<span class="sd">        :param cutoff: cutoff frequency</span>
<span class="sd">        :type cutoff: float</span>
<span class="sd">        :param fs: samplerate of the signal</span>
<span class="sd">        :type fs: float</span>
<span class="sd">        :param order: order of the Butter Filter</span>
<span class="sd">        :type order: int</span>

<span class="sd">        :return: lowpass filtered ECG signal</span>
<span class="sd">        :rtype: list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">butter_lowpass</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">y</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="butter_highpass_filter"><a class="viewcode-back" href="../heartrate.html#electrocardiography.butter_highpass_filter">[docs]</a><span class="k">def</span> <span class="nf">butter_highpass_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This functions apply a butter highpass filter to a signal</span>
<span class="sd">    </span>
<span class="sd">        :param data: ECG signal</span>
<span class="sd">        :type data: list</span>
<span class="sd">        :param cutoff: cutoff frequency</span>
<span class="sd">        :type cutoff: float</span>
<span class="sd">        :param cutoff: cutoff frequency</span>
<span class="sd">        :type cutoff: float</span>
<span class="sd">        :param fs: samplerate of the signal</span>
<span class="sd">        :type fs: float</span>
<span class="sd">        :param order: order of the Butter Filter</span>
<span class="sd">        :type order: int</span>

<span class="sd">        :return: highpass filtered ECG signal</span>
<span class="sd">        :rtype: list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">butter_highpass</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">y</span><span class="p">)</span></div>
    
<span class="c1">#http://www.paulvangent.com/2016/03/15/analyzing-a-discrete-heart-rate-signal-using-python-part-1/</span>
<div class="viewcode-block" id="analyzeECG"><a class="viewcode-back" href="../heartrate.html#electrocardiography.analyzeECG">[docs]</a><span class="k">def</span> <span class="nf">analyzeECG</span><span class="p">(</span><span class="n">rawECGSignal</span><span class="p">,</span><span class="n">samplerate</span><span class="p">,</span><span class="n">preprocessing</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">highpass</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">lowpass</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">min_dist</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="n">peakThresh</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">PeakTreshAbs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">ibi</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">bpm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sdnn</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">sdsd</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">rmssd</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">pnn50</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">pnn20</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">pnn50pnn20</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">freqAnalysis</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">freqAnalysisFiltered</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This is a simple entrypoint for ECG analysis. </span>
<span class="sd">    </span>
<span class="sd">        You can use this function as model for your analysis or to extrapolate several features from an ECG signal.</span>
<span class="sd">        </span>
<span class="sd">        You can specify which features to evaluate or to exclude, as well as cutoff for frequencies and filter.</span>
<span class="sd">        </span>
<span class="sd">        :param data: ECG signal</span>
<span class="sd">        :type data: list</span>
<span class="sd">        :param samplerate: samplerate of the signal in Hz</span>
<span class="sd">        :type samplerate: int </span>
<span class="sd">        :param preprocessing: whether to perform a simple preprocessing of the signal automatically</span>
<span class="sd">        :type preprocessing: boolean</span>
<span class="sd">        :param highpass: cutoff frequency for the high pass filter</span>
<span class="sd">        :type highpass: boolean</span>
<span class="sd">        :param lowpass: cutoff frequency for the low pass filter</span>
<span class="sd">        :type lowpass: boolean</span>
<span class="sd">        :param min_dist: minimum distance between peaks in ms. Used for peak detection</span>
<span class="sd">        :type min_dist: int</span>
<span class="sd">        :param peakThresh: Normalized threshold. Only the peaks with amplitude higher than the threshold will be detected by the peak detection utils</span>
<span class="sd">        :type peakThresh: float</span>
<span class="sd">        :param PeakTreshAbs:  If True, the peakThresh value will be interpreted as an absolute value, instead of a normalized threshold.</span>
<span class="sd">        :type PeakTreshAbs: boolean</span>
<span class="sd">        :param ibi: whether or not to perform the IBI analysis</span>
<span class="sd">        :type ibi: boolean</span>
<span class="sd">        :param bpm: whether or not to perform the BPM analysis</span>
<span class="sd">        :type bpm: boolean</span>
<span class="sd">        :param sdnn: whether or not to perform the sdnn analysis</span>
<span class="sd">        :type sdnn: boolean</span>
<span class="sd">        :param sdsd: whether or not to perform the sdsd analysis</span>
<span class="sd">        :type sdsd: boolean</span>
<span class="sd">        :param rmssd: whether or not to perform the rmssd analysis</span>
<span class="sd">        :type rmssd: boolean</span>
<span class="sd">        :param pnn50: whether or not to perform the pNN50 analysis</span>
<span class="sd">        :type pnn50: boolean</span>
<span class="sd">        :param pnn20: whether or not to perform the pNN20 analysis</span>
<span class="sd">        :type pnn20: boolean</span>
<span class="sd">        :param pnn50pnn20: whether or not to perform the pNN50 on pNN20 ratio analysis</span>
<span class="sd">        :type pnn50pnn20: boolean</span>
<span class="sd">        :param freqAnalysis: whether or not to perform a frequency analysis analysis</span>
<span class="sd">        :type freqAnalysis: boolean</span>
<span class="sd">        :param freqAnalysisFiltered: whether or not to perform a frequency analysis automatically filtering the signal</span>
<span class="sd">        :type freqAnalysisFiltered: boolean</span>

<span class="sd">        :return: a dictionary containing the results of the ECG analysis </span>
<span class="sd">        :rtype: list</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#First we get the peaks</span>
    <span class="k">if</span><span class="p">(</span><span class="n">preprocessing</span><span class="p">):</span>
        <span class="n">filteredECGSignal</span> <span class="o">=</span> <span class="n">butter_lowpass_filter</span><span class="p">(</span><span class="n">rawECGSignal</span><span class="p">,</span> <span class="n">lowpass</span><span class="p">,</span> <span class="n">samplerate</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="c1">#filter the signal with a cutoff at 2.5Hz and a 5th order Butterworth filter</span>
        <span class="n">filteredECGSignal</span> <span class="o">=</span> <span class="n">butter_highpass_filter</span><span class="p">(</span><span class="n">filteredECGSignal</span><span class="p">,</span> <span class="n">highpass</span><span class="p">,</span> <span class="n">samplerate</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="c1">#filter the signal with a cutoff at 2.5Hz and a 5th order Butterworth filter</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">filteredECGSignal</span> <span class="o">=</span> <span class="n">rawECGSignal</span>
    <span class="c1">#min_dist = int(samplerate / 2) #Minimum distance between peaks is set to be 500ms</span>
    <span class="n">min_dist</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">min_dist</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span> <span class="o">*</span><span class="n">samplerate</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">peakutils</span><span class="o">.</span><span class="n">indexes</span><span class="p">(</span><span class="n">filteredECGSignal</span><span class="p">,</span><span class="n">min_dist</span><span class="o">=</span><span class="n">min_dist</span><span class="p">)</span> <span class="c1">#get the list of peaks</span>
    <span class="n">resultsdict</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1">#initialize the results dict.</span>
    <span class="c1">#for each analysis, check the boolean value and if true compute the results. Then append it to the final dict. </span>
    <span class="k">if</span><span class="p">(</span><span class="n">ibi</span><span class="p">):</span> 
        <span class="n">resultsdict</span><span class="p">[</span><span class="s2">&quot;ibi&quot;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">getIBI</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span><span class="n">samplerate</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">bpm</span><span class="p">):</span>
        <span class="n">resultsdict</span><span class="p">[</span><span class="s2">&quot;bpm&quot;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">getBPM</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">rawECGSignal</span><span class="p">),</span><span class="n">samplerate</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">sdnn</span><span class="p">):</span>
        <span class="n">resultsdict</span><span class="p">[</span><span class="s2">&quot;sdnn&quot;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">getSDNN</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span><span class="n">samplerate</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">sdsd</span><span class="p">):</span>
        <span class="n">resultsdict</span><span class="p">[</span><span class="s2">&quot;sdsd&quot;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">getSDSD</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span><span class="n">samplerate</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rmssd</span><span class="p">):</span>
        <span class="n">resultsdict</span><span class="p">[</span><span class="s2">&quot;rmssd&quot;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">getRMSSD</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span><span class="n">samplerate</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pnn50</span><span class="p">):</span>
        <span class="n">resultsdict</span><span class="p">[</span><span class="s2">&quot;pnn50&quot;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">getPNN50</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span><span class="n">samplerate</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pnn20</span><span class="p">):</span>
        <span class="n">resultsdict</span><span class="p">[</span><span class="s2">&quot;pnn20&quot;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">getPNN20</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span><span class="n">samplerate</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pnn50pnn20</span><span class="p">):</span>
        <span class="c1">#We use a  try / except to prevent division by 0 or with null values</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">resultsdict</span><span class="p">[</span><span class="s2">&quot;pnn50pnn20&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">resultsdict</span><span class="p">[</span><span class="s2">&quot;pnn50&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">resultsdict</span><span class="p">[</span><span class="s2">&quot;pnn20&quot;</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unable to compute pnn50pnn20&quot;</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">freqAnalysis</span><span class="p">):</span>
        <span class="n">resultsdict</span><span class="p">[</span><span class="s2">&quot;frequencyAnalysis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">getFrequencies</span><span class="p">(</span><span class="n">rawECGSignal</span><span class="p">,</span><span class="n">samplerate</span> <span class="p">)</span> <span class="c1">#unfiltered Signal</span>
    <span class="k">if</span><span class="p">(</span><span class="n">freqAnalysisFiltered</span><span class="p">):</span>
        <span class="n">resultsdict</span><span class="p">[</span><span class="s2">&quot;frequencyAnalysisFiltered&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">getFrequencies</span><span class="p">(</span><span class="n">filteredECGSignal</span><span class="p">,</span><span class="n">samplerate</span> <span class="p">)</span> <span class="c1">#unfiltered Signal</span>
    <span class="k">return</span><span class="p">(</span><span class="n">resultsdict</span><span class="p">)</span></div>

<span class="c1">###############################################################################</span>
<span class="c1">#                                                                             #</span>
<span class="c1">#                                  DEBUG                                      #</span>
<span class="c1">#                                                                             #</span>
<span class="c1">###############################################################################</span>
<span class="sd">&quot;&quot;&quot; For debug purposes.&quot;&quot;&quot;</span>

<span class="k">if</span><span class="p">(</span><span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">import</span> <span class="nn">pickle</span>
    <span class="kn">import</span> <span class="nn">pprint</span>
    <span class="kn">import</span> <span class="nn">sampledata</span>
    <span class="n">fakesignal</span> <span class="o">=</span> <span class="n">sampledata</span><span class="o">.</span><span class="n">loadsampleECG</span><span class="p">()</span>
    <span class="n">events</span> <span class="o">=</span> <span class="p">[</span><span class="mi">30000</span><span class="p">]</span> <span class="c1">#set a list of fake fake events</span>
    <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#start from the beginning of the events</span>
    <span class="n">tmax</span> <span class="o">=</span> <span class="mi">8</span> <span class="c1">#end from the beginning of the events</span>
    <span class="n">samplerate</span> <span class="o">=</span> <span class="mi">1000</span> <span class="c1">#samplerate of the fake signal</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span> <span class="c1">#for each event</span>
        <span class="n">smin</span> <span class="o">=</span> <span class="n">tmin</span><span class="o">*</span><span class="n">samplerate</span> <span class="o">+</span> <span class="n">event</span>
        <span class="n">smax</span> <span class="o">=</span> <span class="n">tmax</span><span class="o">*</span><span class="n">samplerate</span> <span class="o">+</span> <span class="n">event</span>
        <span class="n">eventSignal</span> <span class="o">=</span> <span class="n">fakesignal</span><span class="p">[</span><span class="n">smin</span><span class="p">:</span><span class="n">smax</span><span class="p">]</span>
        <span class="n">analyzedECG</span> <span class="o">=</span> <span class="n">analyzeECG</span><span class="p">(</span><span class="n">eventSignal</span><span class="p">,</span><span class="n">samplerate</span><span class="p">)</span> <span class="c1">#analyze it</span>
        <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">analyzedECG</span><span class="p">)</span> <span class="c1">#print the results of the analysis</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Pysiology 0.0.9 - Beta version documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Giulio Gabrieli.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>